package main

import (
	"fmt"
	"time"
)

func main() {
	// Основы каналов: что это, как они работают, зачем они нужны.
	// Каналы в Go используются для обмена данными между горутинами.
	// Они обеспечивают синхронизацию и безопасность при передаче данных.

	// Синтаксис создания канала: make(chan type).
	// Создаем канал для передачи целых чисел.
	ch := make(chan int)

	// Основные операции с каналами: отправка и получение данных.
	// Запускаем горутину, которая отправляет данные в канал.
	go func() {
		fmt.Println("Горутина: отправка данных в канал")
		ch <- 42 // Отправляем значение 42 в канал
	}()

	// Блокировка и ожидание получения/отправки данных.
	// Основная горутина ожидает получения данных из канала.
	fmt.Println("Основная горутина: ожидание данных из канала")
	value := <-ch // Получаем данные из канала
	fmt.Printf("Основная горутина: получено значение %d из канала\n", value)

	// Пример с блокировкой и ожиданием.
	// Создаем канал для строк.
	msgCh := make(chan string)

	// Запускаем горутину, которая отправляет сообщение через 2 секунды.
	go func() {
		time.Sleep(2 * time.Second)
		msgCh <- "Привет, мир!"
	}()

	// Основная горутина ожидает сообщение.
	fmt.Println("Основная горутина: ожидание сообщения...")
	msg := <-msgCh
	fmt.Printf("Основная горутина: получено сообщение: %s\n", msg)

	// Пример с закрытием канала.
	// Создаем канал для передачи строк.
	closeCh := make(chan string)

	// Запускаем горутину, которая отправляет несколько сообщений и закрывает канал.
	go func() {
		for i := 1; i <= 3; i++ {
			closeCh <- fmt.Sprintf("Сообщение %d", i)
		}
		close(closeCh) // Закрываем канал после отправки всех сообщений
	}()

	// Основная горутина читает данные из канала до его закрытия.
	fmt.Println("Основная горутина: чтение данных из канала...")
	for msg := range closeCh {
		fmt.Printf("Основная горутина: получено сообщение: %s\n", msg)
	}

	// Пример с буферизированным каналом.
	// Создаем буферизированный канал с емкостью 2.
	bufferedCh := make(chan int, 2)

	// Отправляем данные в буферизированный канал без блокировки.
	bufferedCh <- 1
	bufferedCh <- 2

	// Попытка отправки третьего значения приведет к блокировке, если канал не буферизирован.
	// Но в данном случае канал буферизирован, поэтому блокировки не произойдет.
	fmt.Println("Основная горутина: отправка данных в буферизированный канал")
	bufferedCh <- 3

	// Получаем данные из буферизированного канала.
	fmt.Println("Основная горутина: получение данных из буферизированного канала")
	fmt.Println(<-bufferedCh)
	fmt.Println(<-bufferedCh)
	fmt.Println(<-bufferedCh)
}
